// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, TagUnionValueOffset};

#[allow(unused_imports, dead_code)]
pub mod my_example {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, TagUnionValueOffset};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_PAYLOAD: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_PAYLOAD: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_PAYLOAD: [Payload; 3] =
        [Payload::NONE, Payload::Request, Payload::Response];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Payload(pub u8);
    #[allow(non_upper_case_globals)]
    impl Payload {
        pub const NONE: Self = Self(0);
        pub const Request: Self = Self(1);
        pub const Response: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::Request, Self::Response];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::Request => Some("Request"),
                Self::Response => Some("Response"),
                _ => None,
            }
        }
    }
    impl std::fmt::Debug for Payload {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Payload {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for Payload {
        type Output = Payload;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for Payload {
        #[inline]
        fn to_little_endian(self) -> Self {
            let b = u8::to_le(self.0);
            Self(b)
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let b = u8::from_le(self.0);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Payload {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Payload {}

    pub struct PayloadUnionTableOffset {}

    impl flatbuffers::TaggedUnion for PayloadUnionTableOffset {
        type Tag = Payload;
    }

    impl<'a> flatbuffers::TagUnionValueOffset<Request<'a>> for PayloadUnionTableOffset {
        fn from_value_offset(
            o: flatbuffers::WIPOffset<Request<'a>>,
        ) -> flatbuffers::TaggedWIPOffset<Self> {
            flatbuffers::TaggedWIPOffset {
                tag: Payload::Request,
                value: flatbuffers::WIPOffset::new(o.value()),
            }
        }
    }

    impl<'a> flatbuffers::TagUnionValueOffset<Response<'a>> for PayloadUnionTableOffset {
        fn from_value_offset(
            o: flatbuffers::WIPOffset<Response<'a>>,
        ) -> flatbuffers::TaggedWIPOffset<Self> {
            flatbuffers::TaggedWIPOffset {
                tag: Payload::Response,
                value: flatbuffers::WIPOffset::new(o.value()),
            }
        }
    }

    impl<'a> flatbuffers::UnionVerifiable<'a> for PayloadUnionTableOffset {
        fn run_union_verifier(
            v: &mut flatbuffers::Verifier,
            tag: <<Self as flatbuffers::TaggedUnion>::Tag as flatbuffers::Follow<'a>>::Inner,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            match tag {
                Payload::Request => v
                    .verify_union_variant::<flatbuffers::ForwardsUOffset<Request>>(
                        "Payload::Request",
                        pos,
                    ),
                Payload::Response => v
                    .verify_union_variant::<flatbuffers::ForwardsUOffset<Response>>(
                        "Payload::Response",
                        pos,
                    ),
                _ => Ok(()),
            }
        }
    }

    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub enum PayloadT {
        NONE,
        Request(Box<RequestT>),
        Response(Box<ResponseT>),
    }
    impl Default for PayloadT {
        fn default() -> Self {
            Self::NONE
        }
    }
    impl PayloadT {
        pub fn payload_type(&self) -> Payload {
            match self {
                Self::NONE => Payload::NONE,
                Self::Request(_) => Payload::Request,
                Self::Response(_) => Payload::Response,
            }
        }
        pub fn pack(
            &self,
            fbb: &mut flatbuffers::FlatBufferBuilder,
        ) -> Option<flatbuffers::WIPOffset<PayloadUnionTableOffset>> {
            match self {
                Self::NONE => None,
                Self::Request(v) => {
                    Some(PayloadUnionTableOffset::from_value_offset(v.pack(fbb)).value)
                }
                Self::Response(v) => {
                    Some(PayloadUnionTableOffset::from_value_offset(v.pack(fbb)).value)
                }
            }
        }
        /// If the union variant matches, return the owned RequestT, setting the union to NONE.
        pub fn take_request(&mut self) -> Option<Box<RequestT>> {
            if let Self::Request(_) = self {
                let v = std::mem::replace(self, Self::NONE);
                if let Self::Request(w) = v {
                    Some(w)
                } else {
                    unreachable!()
                }
            } else {
                None
            }
        }
        /// If the union variant matches, return a reference to the RequestT.
        pub fn as_request(&self) -> Option<&RequestT> {
            if let Self::Request(v) = self {
                Some(v.as_ref())
            } else {
                None
            }
        }
        /// If the union variant matches, return a mutable reference to the RequestT.
        pub fn as_request_mut(&mut self) -> Option<&mut RequestT> {
            if let Self::Request(v) = self {
                Some(v.as_mut())
            } else {
                None
            }
        }
        /// If the union variant matches, return the owned ResponseT, setting the union to NONE.
        pub fn take_response(&mut self) -> Option<Box<ResponseT>> {
            if let Self::Response(_) = self {
                let v = std::mem::replace(self, Self::NONE);
                if let Self::Response(w) = v {
                    Some(w)
                } else {
                    unreachable!()
                }
            } else {
                None
            }
        }
        /// If the union variant matches, return a reference to the ResponseT.
        pub fn as_response(&self) -> Option<&ResponseT> {
            if let Self::Response(v) = self {
                Some(v.as_ref())
            } else {
                None
            }
        }
        /// If the union variant matches, return a mutable reference to the ResponseT.
        pub fn as_response_mut(&mut self) -> Option<&mut ResponseT> {
            if let Self::Response(v) = self {
                Some(v.as_mut())
            } else {
                None
            }
        }
    }
    // struct MyStruct, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq, Default)]
    pub struct MyStruct(pub [u8; 4]);
    impl std::fmt::Debug for MyStruct {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("MyStruct")
                .field("my_id", &self.my_id())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for MyStruct {}
    impl flatbuffers::SafeSliceAccess for MyStruct {}
    impl<'a> flatbuffers::Follow<'a> for MyStruct {
        type Inner = &'a MyStruct;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a MyStruct>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a MyStruct {
        type Inner = &'a MyStruct;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<MyStruct>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for MyStruct {
        type Output = MyStruct;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(self as *const MyStruct as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b MyStruct {
        type Output = MyStruct;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(*self as *const MyStruct as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for MyStruct {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }
    impl MyStruct {
        #[allow(clippy::too_many_arguments)]
        pub fn new(my_id: u32) -> Self {
            let mut s = Self([0; 4]);
            s.set_my_id(my_id);
            s
        }

        pub fn my_id(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<u32>::uninit();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<u32>(),
                );
                mem.assume_init()
            }
            .from_little_endian()
        }

        pub fn set_my_id(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const u32 as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<u32>(),
                );
            }
        }

        pub fn unpack(&self) -> MyStructT {
            MyStructT {
                my_id: self.my_id(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct MyStructT {
        pub my_id: u32,
    }
    impl MyStructT {
        pub fn pack(&self) -> MyStruct {
            MyStruct::new(self.my_id)
        }
    }

    pub enum RequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Request<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Request<'a> {
        type Inner = Request<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Request<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Request { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RequestArgs,
        ) -> flatbuffers::WIPOffset<Request<'bldr>> {
            let mut builder = RequestBuilder::new(_fbb);
            builder.add_request_id(args.request_id);
            builder.finish()
        }

        pub fn unpack(&self) -> RequestT {
            let request_id = self.request_id();
            RequestT { request_id }
        }
        pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn request_id(&self) -> u32 {
            self._tab
                .get::<u32>(Request::VT_REQUEST_ID, Some(0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for Request<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>(&"request_id", Self::VT_REQUEST_ID, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RequestArgs {
        pub request_id: u32,
    }
    impl<'a> Default for RequestArgs {
        #[inline]
        fn default() -> Self {
            RequestArgs { request_id: 0 }
        }
    }
    pub struct RequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_request_id(&mut self, request_id: u32) {
            self.fbb_
                .push_slot::<u32>(Request::VT_REQUEST_ID, request_id, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Request<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Request<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Request");
            ds.field("request_id", &self.request_id());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct RequestT {
        pub request_id: u32,
    }
    impl Default for RequestT {
        fn default() -> Self {
            Self { request_id: 0 }
        }
    }
    impl RequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Request<'b>> {
            let request_id = self.request_id;
            Request::create(_fbb, &RequestArgs { request_id })
        }
    }
    pub enum ResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Response<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Response<'a> {
        type Inner = Response<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Response<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Response { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ResponseArgs,
        ) -> flatbuffers::WIPOffset<Response<'bldr>> {
            let mut builder = ResponseBuilder::new(_fbb);
            builder.add_response_id(args.response_id);
            builder.finish()
        }

        pub fn unpack(&self) -> ResponseT {
            let response_id = self.response_id();
            ResponseT { response_id }
        }
        pub const VT_RESPONSE_ID: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn response_id(&self) -> u32 {
            self._tab
                .get::<u32>(Response::VT_RESPONSE_ID, Some(0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for Response<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>(&"response_id", Self::VT_RESPONSE_ID, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ResponseArgs {
        pub response_id: u32,
    }
    impl<'a> Default for ResponseArgs {
        #[inline]
        fn default() -> Self {
            ResponseArgs { response_id: 0 }
        }
    }
    pub struct ResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_response_id(&mut self, response_id: u32) {
            self.fbb_
                .push_slot::<u32>(Response::VT_RESPONSE_ID, response_id, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Response<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for Response<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("Response");
            ds.field("response_id", &self.response_id());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ResponseT {
        pub response_id: u32,
    }
    impl Default for ResponseT {
        fn default() -> Self {
            Self { response_id: 0 }
        }
    }
    impl ResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Response<'b>> {
            let response_id = self.response_id;
            Response::create(_fbb, &ResponseArgs { response_id })
        }
    }
    pub enum MyTableOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MyTable<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MyTable<'a> {
        type Inner = MyTable<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> MyTable<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MyTable { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MyTableArgs<'args>,
        ) -> flatbuffers::WIPOffset<MyTable<'bldr>> {
            let mut builder = MyTableBuilder::new(_fbb);
            if let Some(x) = args.struct_single {
                builder.add_struct_single(x);
            }
            if let Some(x) = args.struct_vector {
                builder.add_struct_vector(x);
            }
            if let Some(x) = args.table_single {
                builder.add_table_single(x);
            }
            if let Some(x) = args.table_vector {
                builder.add_table_vector(x);
            }
            if let Some(x) = args.union_single {
                builder.add_union_single(x);
            }
            if let Some(x) = args.union_vector {
                builder.add_union_vector(x);
            }
            if let Some(x) = args.union_vector_type {
                builder.add_union_vector_type(x);
            }
            builder.add_union_single_type(args.union_single_type);
            builder.finish()
        }

        pub fn unpack(&self) -> MyTableT {
            let union_vector_type = self.union_vector_type().map(|x| x.iter().collect());
            let union_vector = union_vector_type.as_ref().zip(self.union_vector()).map(
                |x: (
                    &Vec<Payload>,
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<flatbuffers::Table<'_>>>,
                )| {
                    x.0.iter()
                        .zip(x.1.iter())
                        .map(|t| {
                            let key = t.0;
                            let table = t.1;
                            match key {
                                &Payload::NONE => PayloadT::NONE,
                                &Payload::Request => PayloadT::Request(Box::new(
                                    Request::init_from_table(table).unpack(),
                                )),
                                &Payload::Response => PayloadT::Response(Box::new(
                                    Response::init_from_table(table).unpack(),
                                )),
                                _ => PayloadT::NONE,
                            }
                        })
                        .collect()
                },
            );
            let union_single = match self.union_single_type() {
                Payload::NONE => PayloadT::NONE,
                Payload::Request => PayloadT::Request(Box::new(
                    self.union_single_as_request()
                        .expect("Invalid union table, expected `Payload::Request`.")
                        .unpack(),
                )),
                Payload::Response => PayloadT::Response(Box::new(
                    self.union_single_as_response()
                        .expect("Invalid union table, expected `Payload::Response`.")
                        .unpack(),
                )),
                _ => PayloadT::NONE,
            };
            let table_vector = self
                .table_vector()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            let table_single = self.table_single().map(|x| Box::new(x.unpack()));
            let struct_vector = self
                .struct_vector()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            let struct_single = self.struct_single().map(|x| x.unpack());
            MyTableT {
                union_vector,
                union_single,
                table_vector,
                table_single,
                struct_vector,
                struct_single,
            }
        }
        pub const VT_UNION_VECTOR_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_UNION_VECTOR: flatbuffers::VOffsetT = 6;
        pub const VT_UNION_SINGLE_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_UNION_SINGLE: flatbuffers::VOffsetT = 10;
        pub const VT_TABLE_VECTOR: flatbuffers::VOffsetT = 12;
        pub const VT_TABLE_SINGLE: flatbuffers::VOffsetT = 14;
        pub const VT_STRUCT_VECTOR: flatbuffers::VOffsetT = 16;
        pub const VT_STRUCT_SINGLE: flatbuffers::VOffsetT = 18;

        #[inline]
        pub fn union_vector_type(&self) -> Option<flatbuffers::Vector<'a, Payload>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Payload>>>(
                    MyTable::VT_UNION_VECTOR_TYPE,
                    None,
                )
        }
        #[inline]
        pub fn union_vector(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>,
            >>(MyTable::VT_UNION_VECTOR, None)
        }
        #[inline]
        pub fn union_single_type(&self) -> Payload {
            self._tab
                .get::<Payload>(MyTable::VT_UNION_SINGLE_TYPE, Some(Payload::NONE))
                .unwrap()
        }
        #[inline]
        pub fn union_single(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MyTable::VT_UNION_SINGLE,
                    None,
                )
        }
        #[inline]
        pub fn table_vector(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request>>,
            >>(MyTable::VT_TABLE_VECTOR, None)
        }
        #[inline]
        pub fn table_single(&self) -> Option<Request<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Request>>(MyTable::VT_TABLE_SINGLE, None)
        }
        #[inline]
        pub fn struct_vector(&self) -> Option<&'a [MyStruct]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, MyStruct>>>(
                    MyTable::VT_STRUCT_VECTOR,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn struct_single(&self) -> Option<&'a MyStruct> {
            self._tab.get::<MyStruct>(MyTable::VT_STRUCT_SINGLE, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn union_single_as_request(&self) -> Option<Request<'a>> {
            if self.union_single_type() == Payload::Request {
                self.union_single().map(Request::init_from_table)
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn union_single_as_response(&self) -> Option<Response<'a>> {
            if self.union_single_type() == Payload::Response {
                self.union_single().map(Response::init_from_table)
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for MyTable<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_union_vector::<PayloadUnionTableOffset>(
                    &"union_vector_type",
                    Self::VT_UNION_VECTOR_TYPE,
                    &"union_vector",
                    Self::VT_UNION_VECTOR,
                    false,
                )?
                .visit_union::<PayloadUnionTableOffset>(
                    &"union_single_type",
                    Self::VT_UNION_SINGLE_TYPE,
                    &"union_single",
                    Self::VT_UNION_SINGLE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Request>>,
                >>(&"table_vector", Self::VT_TABLE_VECTOR, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Request>>(
                    &"table_single",
                    Self::VT_TABLE_SINGLE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, MyStruct>>>(
                    &"struct_vector",
                    Self::VT_STRUCT_VECTOR,
                    false,
                )?
                .visit_field::<MyStruct>(&"struct_single", Self::VT_STRUCT_SINGLE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct MyTableArgs<'a> {
        pub union_vector_type: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Payload>>>,
        pub union_vector: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PayloadUnionTableOffset>>,
            >,
        >,
        pub union_single_type: Payload,
        pub union_single: Option<flatbuffers::WIPOffset<PayloadUnionTableOffset>>,
        pub table_vector: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request<'a>>>,
            >,
        >,
        pub table_single: Option<flatbuffers::WIPOffset<Request<'a>>>,
        pub struct_vector: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, MyStruct>>>,
        pub struct_single: Option<&'a MyStruct>,
    }
    impl<'a> Default for MyTableArgs<'a> {
        #[inline]
        fn default() -> Self {
            MyTableArgs {
                union_vector_type: None,
                union_vector: None,
                union_single_type: Payload::NONE,
                union_single: None,
                table_vector: None,
                table_single: None,
                struct_vector: None,
                struct_single: None,
            }
        }
    }
    pub struct MyTableBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MyTableBuilder<'a, 'b> {
        #[inline]
        pub fn add_union_vector_type(
            &mut self,
            union_vector_type: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Payload>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MyTable::VT_UNION_VECTOR_TYPE,
                union_vector_type,
            );
        }
        #[inline]
        pub fn add_union_vector(
            &mut self,
            union_vector: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PayloadUnionTableOffset>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MyTable::VT_UNION_VECTOR,
                union_vector,
            );
        }
        #[inline]
        pub fn add_union_single_type(&mut self, union_single_type: Payload) {
            self.fbb_.push_slot::<Payload>(
                MyTable::VT_UNION_SINGLE_TYPE,
                union_single_type,
                Payload::NONE,
            );
        }
        #[inline]
        pub fn add_union_single(
            &mut self,
            union_single: flatbuffers::WIPOffset<PayloadUnionTableOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MyTable::VT_UNION_SINGLE,
                union_single,
            );
        }
        #[inline]
        pub fn add_table_vector(
            &mut self,
            table_vector: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Request<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MyTable::VT_TABLE_VECTOR,
                table_vector,
            );
        }
        #[inline]
        pub fn add_table_single(&mut self, table_single: flatbuffers::WIPOffset<Request<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Request>>(
                    MyTable::VT_TABLE_SINGLE,
                    table_single,
                );
        }
        #[inline]
        pub fn add_struct_vector(
            &mut self,
            struct_vector: flatbuffers::WIPOffset<flatbuffers::Vector<'b, MyStruct>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MyTable::VT_STRUCT_VECTOR,
                struct_vector,
            );
        }
        #[inline]
        pub fn add_struct_single(&mut self, struct_single: &MyStruct) {
            self.fbb_
                .push_slot_always::<&MyStruct>(MyTable::VT_STRUCT_SINGLE, struct_single);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MyTableBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MyTableBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MyTable<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for MyTable<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("MyTable");
            ds.field("union_vector_type", &self.union_vector_type());
            ds.field("union_vector", &self.union_vector());
            ds.field("union_single_type", &self.union_single_type());
            match self.union_single_type() {
                Payload::Request => {
                    if let Some(x) = self.union_single_as_request() {
                        ds.field("union_single", &x)
                    } else {
                        ds.field(
                            "union_single",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Payload::Response => {
                    if let Some(x) = self.union_single_as_response() {
                        ds.field("union_single", &x)
                    } else {
                        ds.field(
                            "union_single",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("union_single", &x)
                }
            };
            ds.field("table_vector", &self.table_vector());
            ds.field("table_single", &self.table_single());
            ds.field("struct_vector", &self.struct_vector());
            ds.field("struct_single", &self.struct_single());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct MyTableT {
        pub union_vector: Option<Vec<PayloadT>>,
        pub union_single: PayloadT,
        pub table_vector: Option<Vec<RequestT>>,
        pub table_single: Option<Box<RequestT>>,
        pub struct_vector: Option<Vec<MyStructT>>,
        pub struct_single: Option<MyStructT>,
    }
    impl Default for MyTableT {
        fn default() -> Self {
            Self {
                union_vector: None,
                union_single: PayloadT::NONE,
                table_vector: None,
                table_single: None,
                struct_vector: None,
                struct_single: None,
            }
        }
    }
    impl MyTableT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<MyTable<'b>> {
            let union_vector_type = self.union_vector.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.payload_type()).collect();
                _fbb.create_vector(&w)
            });
            let union_vector = self.union_vector.as_ref().map(|x| {
                let w: Vec<_> = x
                    .iter()
                    .map(|t| match t.pack(_fbb) {
                        Some(o) => o,
                        None => flatbuffers::WIPOffset::new(0u32),
                    })
                    .collect();
                _fbb.create_vector(&w)
            });
            let union_single_type = self.union_single.payload_type();
            let union_single = self.union_single.pack(_fbb);
            let table_vector = self.table_vector.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let table_single = self.table_single.as_ref().map(|x| x.pack(_fbb));
            let struct_vector = self.struct_vector.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack()).collect();
                _fbb.create_vector(&w)
            });
            let struct_single_tmp = self.struct_single.as_ref().map(|x| x.pack());
            let struct_single = struct_single_tmp.as_ref();
            MyTable::create(
                _fbb,
                &MyTableArgs {
                    union_vector_type,
                    union_vector,
                    union_single_type,
                    union_single,
                    table_vector,
                    table_single,
                    struct_vector,
                    struct_single,
                },
            )
        }
    }
    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_root_as_my_table<'a>(buf: &'a [u8]) -> MyTable<'a> {
        unsafe { flatbuffers::root_unchecked::<MyTable<'a>>(buf) }
    }

    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_size_prefixed_root_as_my_table<'a>(buf: &'a [u8]) -> MyTable<'a> {
        unsafe { flatbuffers::size_prefixed_root_unchecked::<MyTable<'a>>(buf) }
    }

    #[inline]
    /// Verifies that a buffer of bytes contains a `MyTable`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_my_table_unchecked`.
    pub fn root_as_my_table(buf: &[u8]) -> Result<MyTable, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<MyTable>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `MyTable` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_my_table_unchecked`.
    pub fn size_prefixed_root_as_my_table(
        buf: &[u8],
    ) -> Result<MyTable, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<MyTable>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `MyTable` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_my_table_unchecked`.
    pub fn root_as_my_table_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<MyTable<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<MyTable<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `MyTable` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_my_table_unchecked`.
    pub fn size_prefixed_root_as_my_table_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<MyTable<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<MyTable<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a MyTable and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `MyTable`.
    pub unsafe fn root_as_my_table_unchecked(buf: &[u8]) -> MyTable {
        flatbuffers::root_unchecked::<MyTable>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed MyTable and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `MyTable`.
    pub unsafe fn size_prefixed_root_as_my_table_unchecked(buf: &[u8]) -> MyTable {
        flatbuffers::size_prefixed_root_unchecked::<MyTable>(buf)
    }
    #[inline]
    pub fn finish_my_table_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<MyTable<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_my_table_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<MyTable<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod MyExample
